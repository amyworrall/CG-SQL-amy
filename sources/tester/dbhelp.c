/*
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

#include "dbhelp.h"

#ifndef _MSC_VER
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wunknown-warning-option"
#pragma clang diagnostic ignored "-Wbitwise-op-parentheses"
#pragma clang diagnostic ignored "-Wshift-op-parentheses"
#pragma clang diagnostic ignored "-Wlogical-not-parentheses"
#pragma clang diagnostic ignored "-Wlogical-op-parentheses"
#pragma clang diagnostic ignored "-Wliteral-conversion"
#pragma clang diagnostic ignored "-Wunused-but-set-variable"
#pragma clang diagnostic ignored "-Wunused-function"
#endif
extern cql_object_ref _Nonnull cql_partition_create(void);
extern cql_bool cql_partition_cursor(cql_object_ref _Nonnull p, cql_dynamic_cursor *_Nonnull key, cql_dynamic_cursor *_Nonnull value);
extern cql_object_ref _Nonnull cql_extract_partition(cql_object_ref _Nonnull p, cql_dynamic_cursor *_Nonnull key);
extern cql_object_ref _Nonnull cql_string_dictionary_create(void);
extern cql_bool cql_string_dictionary_add(cql_object_ref _Nonnull dict, cql_string_ref _Nonnull key, cql_string_ref _Nonnull value);
extern cql_string_ref _Nullable cql_string_dictionary_find(cql_object_ref _Nonnull dict, cql_string_ref _Nullable key);
extern cql_string_ref _Nonnull cql_cursor_format(cql_dynamic_cursor *_Nonnull C);
extern cql_object_ref _Nonnull create_cql_string_list(void);
extern cql_object_ref _Nonnull set_in_object_cql_string_list(cql_object_ref _Nonnull list, cql_int32 index_, cql_string_ref _Nonnull value_);
extern cql_string_ref _Nullable get_from_object_cql_string_list(cql_object_ref _Nonnull list, cql_int32 index_);
extern cql_int32 get_object_cql_string_list_count(cql_object_ref _Nonnull list);
extern cql_object_ref _Nonnull add_object_cql_string_list(cql_object_ref _Nonnull list, cql_string_ref _Nonnull string);
extern CQL_WARN_UNUSED cql_code dbhelp_source(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt);
extern cql_object_ref _Nullable cql_fopen(cql_string_ref _Nonnull name, cql_string_ref _Nonnull mode);
extern cql_string_ref _Nullable readline_object_file(cql_object_ref _Nonnull f);
extern cql_int32 atoi_at_text(cql_string_ref _Nonnull str, cql_int32 offset);
extern cql_int32 len_text(cql_string_ref _Nonnull self);
extern cql_bool starts_with_text(cql_string_ref _Nonnull haystack, cql_string_ref _Nonnull needle);
extern cql_int32 index_of_text(cql_string_ref _Nonnull haystack, cql_string_ref _Nonnull needle);
cql_string_literal(_literal_1_The_statement_ending_at_line_dbhelp_main, "The statement ending at line ");
cql_string_literal(_literal_2_r_dbhelp_main, "r");


//
// This file (dbhelp.c) is auto-generated by dbhelp.sql, it is checked in just
// in case CQL is broken by a change.  The Last Known Good Verifier
// can be used to verify the tests pass again, or report failures
// while things are still otherwise broken.  Rebuild with 'regen.sh'
//

#undef cql_error_trace
#define cql_error_trace() fprintf(stderr, "SQL Failure %d %s: %s %d\n", _rc_, sqlite3_errmsg(_db_), __FILE__, __LINE__)

// Generated from dbhelp.sql:44

/*
CREATE PROC dbhelp_setup ()
BEGIN
  CREATE TABLE test_output(
    line INTEGER NOT NULL,
    data TEXT NOT NULL
  );
  CREATE INDEX __idx__test_lines ON test_output (line);
  CREATE TABLE source_input(
    line INTEGER NOT NULL,
    data TEXT NOT NULL
  );
  CREATE INDEX __idx__source_lines ON source_input (line);
END;
*/

#define _PROC_ "dbhelp_setup"
CQL_WARN_UNUSED cql_code dbhelp_setup(sqlite3 *_Nonnull _db_) {
  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();

  _rc_ = cql_exec(_db_,
    "CREATE TABLE test_output( "
      "line INTEGER NOT NULL, "
      "data TEXT NOT NULL "
    ")");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "CREATE INDEX __idx__test_lines ON test_output (line)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "CREATE TABLE source_input( "
      "line INTEGER NOT NULL, "
      "data TEXT NOT NULL "
    ")");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = cql_exec(_db_,
    "CREATE INDEX __idx__source_lines ON source_input (line)");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:54

/*
CREATE PROC dbhelp_prev_line (line_ INTEGER NOT NULL, OUT prev INTEGER NOT NULL)
BEGIN
  BEGIN TRY
    SET prev := ( SELECT ifnull(max(line), -1)
      FROM test_output
      WHERE line < line_ );
  END TRY;
  BEGIN CATCH
    SET prev := 0;
  END CATCH;
END;
*/

#define _PROC_ "dbhelp_prev_line"
CQL_WARN_UNUSED cql_code dbhelp_prev_line(sqlite3 *_Nonnull _db_, cql_int32 line_, cql_int32 *_Nonnull prev) {
  cql_contract_argument_notnull((void *)prev, 2);

  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();
  sqlite3_stmt *_temp_stmt = NULL;

  *prev = 0; // set out arg to non-garbage
  // try
  {
    _rc_ = cql_prepare(_db_, &_temp_stmt,
      "SELECT ifnull(max(line), -1) "
        "FROM test_output "
        "WHERE line < ?");
    cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                  CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line_);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_1; }
    _rc_ = sqlite3_step(_temp_stmt);
    if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto catch_start_1; }
      *prev = sqlite3_column_int(_temp_stmt, 0);
    cql_finalize_stmt(&_temp_stmt);
    goto catch_end_1;
  }
  catch_start_1: {
    *prev = 0;
  }
  catch_end_1:;
  _rc_ = SQLITE_OK;

  cql_error_report();
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:61

/*
CREATE PROC dbhelp_add (line INTEGER NOT NULL, data TEXT NOT NULL)
BEGIN
  INSERT INTO test_output(line, data)
    VALUES(line, data);
END;
*/

#define _PROC_ "dbhelp_add"
CQL_WARN_UNUSED cql_code dbhelp_add(sqlite3 *_Nonnull _db_, cql_int32 line, cql_string_ref _Nonnull data) {
  cql_contract_argument_notnull((void *)data, 2);

  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO test_output(line, data) "
      "VALUES(?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, data);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:68

/*
CREATE PROC dbhelp_add_source (line INTEGER NOT NULL, data TEXT NOT NULL)
BEGIN
  INSERT INTO source_input(line, data)
    VALUES(line, data);
END;
*/

#define _PROC_ "dbhelp_add_source"
CQL_WARN_UNUSED cql_code dbhelp_add_source(sqlite3 *_Nonnull _db_, cql_int32 line, cql_string_ref _Nonnull data) {
  cql_contract_argument_notnull((void *)data, 2);

  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();
  sqlite3_stmt *_temp_stmt = NULL;

  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "INSERT INTO source_input(line, data) "
      "VALUES(?, ?)");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, data);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:78

/*
CREATE PROC dbhelp_dump_output (line_ INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR FOR
    SELECT *
      FROM test_output
      WHERE line = line_;
  LOOP FETCH C
  BEGIN
    CALL printf('%s', C.data);
  END;
END;
*/

#define _PROC_ "dbhelp_dump_output"

typedef struct dbhelp_dump_output_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 line;
  cql_string_ref _Nonnull data;
} dbhelp_dump_output_C_row;

#define dbhelp_dump_output_C_refs_offset cql_offsetof(dbhelp_dump_output_C_row, data) // count = 1
CQL_WARN_UNUSED cql_code dbhelp_dump_output(sqlite3 *_Nonnull _db_, cql_int32 line_) {
  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();
  sqlite3_stmt *C_stmt = NULL;
  dbhelp_dump_output_C_row C = { ._refs_count_ = 1, ._refs_offset_ = dbhelp_dump_output_C_refs_offset };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT line, data "
      "FROM test_output "
      "WHERE line = ?");
  cql_multibind(&_rc_, _db_, &C_stmt, 1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 2,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.line,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.data);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!C._has_row_) break;
    cql_alloc_cstr(_cstr_1, C.data);
    printf("%s", _cstr_1);
    cql_free_cstr(_cstr_1, C.data);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:105

/*
CREATE PROC dbhelp_find (line_ INTEGER NOT NULL, pattern TEXT NOT NULL, OUT search_line INTEGER NOT NULL, OUT found INTEGER NOT NULL)
BEGIN
  BEGIN TRY
    SET search_line := ( SELECT line
      FROM test_output
      WHERE line >= line_
      LIMIT 1 );
  END TRY;
  BEGIN CATCH
    CALL printf("no lines come after %d\n", line_);
    CALL printf("available test output lines: %d\n", ( SELECT count(*)
      FROM test_output ));
    CALL printf("max line number: %d\n", ( SELECT max(line)
      FROM test_output ));
    THROW;
  END CATCH;
  SET found := ( SELECT count(*)
    FROM test_output
    WHERE line = search_line AND data LIKE pattern );
END;
*/

#define _PROC_ "dbhelp_find"
CQL_WARN_UNUSED cql_code dbhelp_find(sqlite3 *_Nonnull _db_, cql_int32 line_, cql_string_ref _Nonnull pattern, cql_int32 *_Nonnull search_line, cql_int32 *_Nonnull found) {
  cql_contract_argument_notnull((void *)pattern, 2);
  cql_contract_argument_notnull((void *)search_line, 3);
  cql_contract_argument_notnull((void *)found, 4);

  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();
  cql_int32 _tmp_int_0 = 0;
  cql_nullable_int32 _tmp_n_int_0 = { .is_null = 1 };
  sqlite3_stmt *_temp_stmt = NULL;

  *search_line = 0; // set out arg to non-garbage
  *found = 0; // set out arg to non-garbage
  // try
  {
    _rc_ = cql_prepare(_db_, &_temp_stmt,
      "SELECT line "
        "FROM test_output "
        "WHERE line >= ? "
        "LIMIT 1");
    cql_multibind(&_rc_, _db_, &_temp_stmt, 1,
                  CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line_);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto catch_start_2; }
    _rc_ = sqlite3_step(_temp_stmt);
    if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto catch_start_2; }
      *search_line = sqlite3_column_int(_temp_stmt, 0);
    cql_finalize_stmt(&_temp_stmt);
    goto catch_end_2;
  }
  catch_start_2: {
    int32_t _rc_thrown_1 = _rc_;
    printf("no lines come after %d\n", line_);
    _rc_ = cql_prepare(_db_, &_temp_stmt,
      "SELECT count(*) "
        "FROM test_output");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = sqlite3_step(_temp_stmt);
    if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
      _tmp_int_0 = sqlite3_column_int(_temp_stmt, 0);
    cql_finalize_stmt(&_temp_stmt);
    printf("available test output lines: %d\n", _tmp_int_0);
    _rc_ = cql_prepare(_db_, &_temp_stmt,
      "SELECT max(line) "
        "FROM test_output");
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = sqlite3_step(_temp_stmt);
    if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
      cql_column_nullable_int32(_temp_stmt, 0, &_tmp_n_int_0);
    cql_finalize_stmt(&_temp_stmt);
    printf("max line number: %d\n", _tmp_n_int_0.value);
    _rc_ = cql_best_error(_rc_thrown_1);
    cql_error_trace();
    goto cql_cleanup;
  }
  catch_end_2:;
  _rc_ = cql_prepare(_db_, &_temp_stmt,
    "SELECT count(*) "
      "FROM test_output "
      "WHERE line = ? AND data LIKE ?");
  cql_multibind(&_rc_, _db_, &_temp_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, *search_line,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, pattern);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = sqlite3_step(_temp_stmt);
  if (_rc_ != SQLITE_ROW) { cql_error_trace(); goto cql_cleanup; }
    *found = sqlite3_column_int(_temp_stmt, 0);
  cql_finalize_stmt(&_temp_stmt);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  cql_finalize_stmt(&_temp_stmt);
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:115

/*
CREATE PROC dbhelp_dump_source (line1 INTEGER NOT NULL, line2 INTEGER NOT NULL)
BEGIN
  DECLARE C CURSOR FOR
    SELECT *
      FROM source_input
      WHERE line > line1 AND line <= line2;
  LOOP FETCH C
  BEGIN
    CALL printf('%s', C.data);
  END;
END;
*/

#define _PROC_ "dbhelp_dump_source"

typedef struct dbhelp_dump_source_C_row {
  cql_bool _has_row_;
  cql_uint16 _refs_count_;
  cql_uint16 _refs_offset_;
  cql_int32 line;
  cql_string_ref _Nonnull data;
} dbhelp_dump_source_C_row;

#define dbhelp_dump_source_C_refs_offset cql_offsetof(dbhelp_dump_source_C_row, data) // count = 1
CQL_WARN_UNUSED cql_code dbhelp_dump_source(sqlite3 *_Nonnull _db_, cql_int32 line1, cql_int32 line2) {
  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();
  sqlite3_stmt *C_stmt = NULL;
  dbhelp_dump_source_C_row C = { ._refs_count_ = 1, ._refs_offset_ = dbhelp_dump_source_C_refs_offset };

  _rc_ = cql_prepare(_db_, &C_stmt,
    "SELECT line, data "
      "FROM source_input "
      "WHERE line > ? AND line <= ?");
  cql_multibind(&_rc_, _db_, &C_stmt, 2,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line1,
                CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line2);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  for (;;) {
    _rc_ = sqlite3_step(C_stmt);
    C._has_row_ = _rc_ == SQLITE_ROW;
    cql_multifetch(_rc_, C_stmt, 2,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, &C.line,
                   CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_STRING, &C.data);
    if (_rc_ != SQLITE_ROW && _rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    if (!C._has_row_) break;
    cql_alloc_cstr(_cstr_2, C.data);
    printf("%s", _cstr_2);
    cql_free_cstr(_cstr_2, C.data);
  }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  cql_finalize_stmt(&C_stmt);
  cql_teardown_row(C);
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:121

/*
CREATE PROC dbhelp_source ()
BEGIN
  SELECT *
    FROM source_input;
END;
*/

#define _PROC_ "dbhelp_source"
static int32_t dbhelp_source_perf_index;

cql_string_proc_name(dbhelp_source_stored_procedure_name, "dbhelp_source");

typedef struct dbhelp_source_row {
  cql_int32 line;
  cql_string_ref _Nonnull data;
} dbhelp_source_row;

cql_int32 dbhelp_source_get_line(dbhelp_source_result_set_ref _Nonnull result_set, cql_int32 row) {
  dbhelp_source_row *data = (dbhelp_source_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].line;
}

cql_string_ref _Nonnull dbhelp_source_get_data(dbhelp_source_result_set_ref _Nonnull result_set, cql_int32 row) {
  dbhelp_source_row *data = (dbhelp_source_row *)cql_result_set_get_data((cql_result_set_ref)result_set);
  return data[row].data;
}

uint8_t dbhelp_source_data_types[dbhelp_source_data_types_count] = {
  CQL_DATA_TYPE_INT32 | CQL_DATA_TYPE_NOT_NULL, // line
  CQL_DATA_TYPE_STRING | CQL_DATA_TYPE_NOT_NULL, // data
};

#define dbhelp_source_refs_offset cql_offsetof(dbhelp_source_row, data) // count = 1

static cql_uint16 dbhelp_source_col_offsets[] = { 2,
  cql_offsetof(dbhelp_source_row, line),
  cql_offsetof(dbhelp_source_row, data)
};

cql_int32 dbhelp_source_result_count(dbhelp_source_result_set_ref _Nonnull result_set) {
  return cql_result_set_get_count((cql_result_set_ref)result_set);
}

CQL_WARN_UNUSED cql_code dbhelp_source_fetch_results(sqlite3 *_Nonnull _db_, dbhelp_source_result_set_ref _Nullable *_Nonnull result_set) {
  sqlite3_stmt *stmt = NULL;
  cql_profile_start(CRC_dbhelp_source, &dbhelp_source_perf_index);
  cql_code rc = dbhelp_source(_db_, &stmt);
  cql_fetch_info info = {
    .rc = rc,
    .db = _db_,
    .stmt = stmt,
    .data_types = dbhelp_source_data_types,
    .col_offsets = dbhelp_source_col_offsets,
    .refs_count = 1,
    .refs_offset = dbhelp_source_refs_offset,
    .encode_context_index = -1,
    .rowsize = sizeof(dbhelp_source_row),
    .crc = CRC_dbhelp_source,
    .perf_index = &dbhelp_source_perf_index,
  };
  return cql_fetch_all_results(&info, (cql_result_set_ref *)result_set);
}

CQL_WARN_UNUSED cql_code dbhelp_source(sqlite3 *_Nonnull _db_, sqlite3_stmt *_Nullable *_Nonnull _result_stmt) {
  cql_code _rc_ = SQLITE_OK;
  *_result_stmt = NULL;
  cql_error_prepare();

  _rc_ = cql_prepare(_db_, _result_stmt,
    "SELECT line, data "
      "FROM source_input");
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  if (_rc_ == SQLITE_OK && !*_result_stmt) _rc_ = cql_no_rows_stmt(_db_, _result_stmt);
  return _rc_;
}
#undef _PROC_

// Generated from dbhelp.sql:208

/*
CREATE PROC dbhelp_main (args OBJECT<cql_string_list> NOT NULL)
BEGIN
  LET argc := get_object_cql_string_list_count(args);
  LET i := 0;
  IF argc <> 3 THEN
    CALL printf("usage cql-verify foo.sql foo.out\n");
    CALL printf("cql-verify is a test tool.  It processes the input foo.sql\n");
    CALL printf("looking for patterns to match in the CQL output foo.out\n");
    THROW;
  END IF;
  CALL dbhelp_setup();
  LET prefix := "The statement ending at line ";
  LET sql_name := ifnull_throw(get_from_object_cql_string_list(args, 1));
  LET result_name := ifnull_throw(get_from_object_cql_string_list(args, 2));
  LET sql := cql_fopen(sql_name, "r");
  IF sql IS NULL THEN
    CALL printf("unable to open file '%s'\n", sql_name);
    THROW;
  END IF;
  LET result := cql_fopen(result_name, "r");
  IF result IS NULL THEN
    CALL printf("unable to open file '%s'\n", result_name);
    THROW;
  END IF;
  LET line := 0;
  LET len := len_text(prefix);
  DECLARE data TEXT;
  WHILE TRUE
  BEGIN
    SET data := readline_object_file(result);
    IF data IS NULL THEN
      LEAVE;
    END IF;
    LET loc := index_of_text(data, prefix);
    IF loc >= 0 THEN
      SET line := atoi_at_text(data, loc + len);
    END IF;
    INSERT INTO test_output(line, data)
      VALUES(line, data);
  END;
  SET result := NULL;
  SET line := 1;
  WHILE TRUE
  BEGIN
    SET data := readline_object_file(sql);
    IF data IS NULL THEN
      LEAVE;
    END IF;
    INSERT INTO source_input(line, data)
      VALUES(line, data);
    SET line := line + 1;
  END;
  SET sql := NULL;
END;
*/

#define _PROC_ "dbhelp_main"
CQL_WARN_UNUSED cql_code dbhelp_main(sqlite3 *_Nonnull _db_, cql_object_ref _Nonnull args) {
  cql_contract_argument_notnull((void *)args, 1);

  cql_code _rc_ = SQLITE_OK;
  cql_error_prepare();
  cql_int32 argc = 0;
  cql_int32 i = 0;
  cql_string_ref prefix = NULL;
  cql_string_ref _tmp_n_text_0 = NULL;
  cql_string_ref sql_name = NULL;
  cql_string_ref result_name = NULL;
  cql_object_ref sql = NULL;
  cql_object_ref result = NULL;
  cql_int32 line = 0;
  cql_int32 len = 0;
  cql_string_ref data = NULL;
  cql_int32 loc = 0;
  sqlite3_stmt *_temp1_stmt = NULL;
  sqlite3_stmt *_temp2_stmt = NULL;

  argc = get_object_cql_string_list_count(args);
  i = 0;
  if (argc != 3) {
    printf("usage cql-verify foo.sql foo.out\n");
    printf("cql-verify is a test tool.  It processes the input foo.sql\n");
    printf("looking for patterns to match in the CQL output foo.out\n");
    _rc_ = cql_best_error(SQLITE_OK);
    cql_error_trace();
    goto cql_cleanup;
  }
  _rc_ = dbhelp_setup(_db_);
  if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
  cql_set_string_ref(&prefix, _literal_1_The_statement_ending_at_line_dbhelp_main);
  cql_set_string_ref(&_tmp_n_text_0, get_from_object_cql_string_list(args, 1));
  if (!_tmp_n_text_0) {
    _rc_ = SQLITE_ERROR;
    cql_error_trace();
    goto cql_cleanup;
  }
  cql_set_string_ref(&sql_name, _tmp_n_text_0);
  cql_set_string_ref(&_tmp_n_text_0, get_from_object_cql_string_list(args, 2));
  if (!_tmp_n_text_0) {
    _rc_ = SQLITE_ERROR;
    cql_error_trace();
    goto cql_cleanup;
  }
  cql_set_string_ref(&result_name, _tmp_n_text_0);
  cql_object_release(sql);
  sql = cql_fopen(sql_name, _literal_2_r_dbhelp_main);
  if (!sql) {
    cql_alloc_cstr(_cstr_3, sql_name);
    printf("unable to open file '%s'\n", _cstr_3);
    cql_free_cstr(_cstr_3, sql_name);
    _rc_ = cql_best_error(SQLITE_OK);
    cql_error_trace();
    goto cql_cleanup;
  }
  cql_object_release(result);
  result = cql_fopen(result_name, _literal_2_r_dbhelp_main);
  if (!result) {
    cql_alloc_cstr(_cstr_4, result_name);
    printf("unable to open file '%s'\n", _cstr_4);
    cql_free_cstr(_cstr_4, result_name);
    _rc_ = cql_best_error(SQLITE_OK);
    cql_error_trace();
    goto cql_cleanup;
  }
  line = 0;
  len = len_text(prefix);
  for (;;) {
    if (!(1)) break;
    cql_string_release(data);
    data = readline_object_file(result);
    if (!data) {
      break;
    }
    loc = index_of_text(data, prefix);
    if (loc >= 0) {
      line = atoi_at_text(data, loc + len);
    }
    if (!_temp1_stmt) {
      _rc_ = cql_prepare(_db_, &_temp1_stmt,
      "INSERT INTO test_output(line, data) "
        "VALUES(?, ?)");
    }
    else {
      _rc_ = SQLITE_OK;
    }
    cql_multibind(&_rc_, _db_, &_temp1_stmt, 2,
                  CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line,
                  CQL_DATA_TYPE_STRING, data);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = sqlite3_step(_temp1_stmt);
    if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    sqlite3_reset(_temp1_stmt);
  }
  cql_set_object_ref(&result, NULL);
  line = 1;
  for (;;) {
    if (!(1)) break;
    cql_string_release(data);
    data = readline_object_file(sql);
    if (!data) {
      break;
    }
    if (!_temp2_stmt) {
      _rc_ = cql_prepare(_db_, &_temp2_stmt,
      "INSERT INTO source_input(line, data) "
        "VALUES(?, ?)");
    }
    else {
      _rc_ = SQLITE_OK;
    }
    cql_multibind(&_rc_, _db_, &_temp2_stmt, 2,
                  CQL_DATA_TYPE_NOT_NULL | CQL_DATA_TYPE_INT32, line,
                  CQL_DATA_TYPE_STRING, data);
    if (_rc_ != SQLITE_OK) { cql_error_trace(); goto cql_cleanup; }
    _rc_ = sqlite3_step(_temp2_stmt);
    if (_rc_ != SQLITE_DONE) { cql_error_trace(); goto cql_cleanup; }
    sqlite3_reset(_temp2_stmt);
    line = line + 1;
  }
  cql_set_object_ref(&sql, NULL);
  _rc_ = SQLITE_OK;

cql_cleanup:
  cql_error_report();
  cql_string_release(prefix);
  cql_string_release(sql_name);
  cql_string_release(_tmp_n_text_0);
  cql_string_release(result_name);
  cql_object_release(sql);
  cql_object_release(result);
  cql_string_release(data);
  cql_finalize_stmt(&_temp1_stmt);
  cql_finalize_stmt(&_temp2_stmt);
  return _rc_;
}
#undef _PROC_
#pragma clang diagnostic pop
